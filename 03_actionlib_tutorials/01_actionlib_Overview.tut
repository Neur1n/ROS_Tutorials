http://wiki.ros.org/actionlib

The actionlib package provides tools to create servers that execute long-running
goals that can be preempted. It also provides a client interface in order to 
send requests to the server.

Examples of this include moving the base to a target location, performing a 
laser scan and returning the resulting point cloud, detecting the handle of a 
door, etc.

#=============================================================================== 1. Client-Server Interaction
----------------                          ----------------
| ActionClient | --ROS Action Protocol--> | ActionServer |
----------------                          ----------------

(request goals)     (built on top of      (execute goals)
                      ROS messages)
#
# Check screenshot 01_actionlib_client_server_interaction.png.
#

#=============================================================================== 2. Action Specification
NOTE They are 3 kinds of messages. 
#-------------------------------------------------------------------------- 2.1 Goal
Goal: AC --> AS
#
# Example: where do I want to go?
#

#-------------------------------------------------------------------------- 2.2 Feedback
Feedback: provides server implementers a way to tell an ActionClient about the 
          incremental progress of a goal
#
# Example: where am I?
#

#-------------------------------------------------------------------------- 2.3 Result
Result: AS --> AC, be sent exactly once

#=============================================================================== 3. .action File
It has the goal definition, followed by the result definition, followed by the
feedback definition, with each section separated by 3 hyphens (---).
#
# Placed in [your_package]/action directory.
#
# Example: ./action/DoDishes.action
#
#     # Define the goal
#     uint32 dishwasher_id  # Specify which dishwasher we want to use
#     ---
#     # Define the result
#     uint32 total_dishes_cleaned
#     ---
#     # Define a feedback message
#     float32 percent_complete
#

#-------------------------------------------------------------------------- 3.1 Catkin
Append the following to CMakeLists.txt:

    find_package(catkin REQUIRED genmsg actionlib_msgs actionlib)
    add_action_files(DIRECTORY action FILES DoDishes.action)
    generate_messages(DEPENDENCIES actionlib_msgs)

Include the following in package.xml:

    <build_depend>actionlib</build_depend>
    <build_depend>actionlib_msgs</build_depend>
    <run_depend>actionlib</run_depend>
    <run_depend>actionlib_msgs</run_depend>

#-------------------------------------------------------------------------- 3.2 Results
For the DoDishes.action, the following messages are generated by genaction.py:

    DoDishesAction.msg
    DoDishesActionGoal.msg
    DoDishesActionResult.msg
    DoDishesActionFeedback.msg
    DoDishesGoal.msg
    DoDishesResult.msg
    DoDishesFeedback.msg

These are used internally by actionlib to communicate between AC and AS.

#=============================================================================== 4. C++ SimpleActionClient
# Full API reference:
#
#     http://docs.ros.org/api/actionlib/html/classactionlib_1_1SimpleActionClient.html
#
Quick start guide:

Suppose a DoDishes.action file is defined in the chores package. The following
snippet shows how to send a goal to a DoDishes ActionServer called "do_dishes":

    #include <chores/DoDishesAction.h>
    #include <actionlib/client/simple_action_client.h>

    typedef actionlib::SimpleActionClient<chores::DoDishesAction> Client;

    int main(int argc, char** argv)
    {
      ros::init(argc, argv, "do_dishes_client");
      Client client("do_dishes", true); // true -> don't need ros::spin()
      client.waitForServer();
      chores::DoDishesGoal goal;
      // Fill in goal here
      client.sendGoal(goal);
      client.waitForResult(ros::Duration(5.0));
      if (client.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)
        printf("Yay! The dishes are now clean");
      printf("Current State: %s\n", client.getState().toString().c_str());
      return 0;
    }

NOTE For the C++ SimpleActionClient,waitForServer() will only work if a separate
     thread is servicing the client's callback queue. This requires passing in 
     true for the spin_thread option of the client's constructor, running with a
     multi-threaded spinner, or using your own thread to service ROS callback
     queues.

#=============================================================================== 5. C++ SimpleActionServer
# Full API reference:
#
#     http://docs.ros.org/api/actionlib/html/classactionlib_1_1SimpleActionServer.html
#
The following snippet shows how to write a DoDishes ActionServer called
"do_dishes":

    #include <chores/DoDishesAction.h>
    #include <actionlib/server/simple_action_server.h>

    typedef actionlib::SimpleActionServer<chores::DoDishesAction> Server;

    void execute(const chores::DoDishesGoalConstPtr& goal, Server* as)
    {
      // Do lots of awesome groundbreaking robot stuff here
      as->setSucceeded();
    }

    int main(int argc, char** argv)
    {
      ros::init(argc, argv, "do_dishes_server");
      ros::NodeHandle n;
      Server server(n, "do_dishes", boost::bind(&execute, _1, &server), false);
      server.start();
      ros::spin();
      return 0;
    }

#=============================================================================== 6. SimpleAS Goal Policies
"Single Goal Policy":

    (1) only one goal is active at a time
    (2) new goals preempt previous goals based on the stamp in their GoalID 
        field (later goals preempt earlier ones)
    (3) an explicit preempt goal preempts all goals with timestamps that are 
        less than or equal to the stamp associated with the preempt
    (4) accepting a new goal implies successful preemption of any old goal and 
        the status of the old goal will be change automatically to reflect this
